#tag ClassProtected Class gzipStream	#tag Method, Flags = &h21		Private Sub Constructor(f as FolderItem, openForWriting as Boolean = false)		  if f is nil then		    dim oops as new NilObjectException		    oops.Message = CurrentMethodName + ": parameter f cannot be nil."		    raise oops		  end if		  		  soft declare function gzopen lib zlibPath (path as CString, mode as CString) as Ptr		  		  me.gzFile = gzopen(ReplaceAll(f.ShellPath, "\", ""), Mode(openForWriting))		  if me.gzFile = nil then		    dim error as Integer = gzipException.libcErrorCode		    if error <> 0 then		      GZipException.RaiselibcError(error)		    else		      //according to the header file, this case means that the zlib error is Z_MEM_ERROR.		      GZipException.RaisegzipError(GZipException.MEM_ERROR)		    end if		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function Create(f as FolderItem) As GZipStream		  if f is nil then		    dim oops as new NilObjectException		    oops.Message = CurrentMethodName + ": parameter f cannot be nil."		    raise oops		  end if		  		  const openForWriting = true		  return new GZipStream(f, openForWriting)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Destructor()		  		  		  if me.gzFile = nil then		    return		  end if		  		  soft declare function gzclose lib zlibPath (file as Ptr) as Integer		  		  dim errorcode as Integer = gzclose(me.gzFile)		  #pragma unused errorcode		  		  me.gzFile = nil		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub Flush()		  'ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));		  '/*		  'Flushes all pending output into the compressed file. The parameter		  'flush is as in the deflate() function. The return value is the zlib		  'error number (see function gzerror below). gzflush returns Z_OK if		  'the flush parameter is Z_FINISH and all output could be flushed.		  'gzflush should be called only when strictly necessary because it can		  'degrade compression.		  '*/		  		  		  soft declare function gzflush lib zlibPath (file as Ptr, flush as Integer) as Integer		End Sub	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function gzipErrorCode(g as Ptr) As Integer		  soft declare function gzerror lib zlibPath (file as Ptr, ByRef errnum as Integer) as Ptr		  		  dim errnum as Integer		  dim m as MemoryBlock = gzerror(g, errnum)		  #pragma unused m		  return errnum		End Function	#tag EndMethod	#tag Method, Flags = &h21		Private Shared Function Mode(openForWriting as Boolean) As String		  if openForWriting then		    return "wb"		  else		    return "rb"		  end if		End Function	#tag EndMethod	#tag Method, Flags = &h0		 Shared Function Open(f as FolderItem) As GZipStream		  if f is nil then		    dim oops as new NilObjectException		    oops.Message = CurrentMethodName + ": parameter f cannot be nil."		    raise oops		  end if		  		  return new GZipStream(f)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function Read(count as Integer) As MemoryBlock		  if count < 1 then		    return new MemoryBlock(0)		  end if		  		  soft declare function gzread lib zlibPath (file as Ptr, buf as Ptr, len as UInt32) as Integer		  		  dim m as new MemoryBlock(count)		  dim result as Integer = gzread(me.gzFile, m, m.Size)		  if result >=  0 then		    return m.LeftB(result)		  else		    'raise new GZipException(me.gzFile)		  end if		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadBoolean() As Boolean		  dim m as MemoryBlock = me.Read(sizeOfBoolean)		  return m.BooleanValue(0)		  		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadCurrency() As Currency		  dim m as MemoryBlock = me.Read(sizeOfCurrency)		  return m.CurrencyValue(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadDouble() As Double		  dim m as MemoryBlock = me.Read(sizeOfDouble)		  return m.DoubleValue(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadInt16() As Int16		  dim m as MemoryBlock = me.Read(sizeOfInt16)		  return m.Int16Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadInt32() As Int32		  dim m as MemoryBlock = me.Read(sizeOfInt32)		  return m.Int32Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadInt64() As Int64		  dim m as MemoryBlock = me.Read(8)		  return m.Int64Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadInt8() As Int8		  dim m as MemoryBlock = me.Read(1)		  return m.Int8Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadPString() As String		  return me.Read(me.ReadUInt8)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadSingle() As Single		  dim m as MemoryBlock = me.Read(4)		  return m.SingleValue(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadUInt16() As UInt16		  dim m as MemoryBlock = me.Read(2)		  return m.UInt16Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadUInt32() As Uint32		  dim m as MemoryBlock = me.Read(4)		  return m.UInt32Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadUInt64() As UInt64		  dim m as MemoryBlock = me.Read(8)		  return m.UInt64Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Function ReadUInt8() As UInt8		  dim m as MemoryBlock = me.Read(1)		  return m.UInt8Value(0)		End Function	#tag EndMethod	#tag Method, Flags = &h0		Sub Write(text as String)		  soft declare function gzwrite lib zlibPath (file as Ptr, buf as CString, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, text, LenB(text))		  //note that bytesWritten = 0 is not an error if text = "".  That text = "" is not an error remains to be tested on all platforms.		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteBoolean(value as Boolean)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Boolean, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfBoolean)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteCurrency(value as Currency)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Currency, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfCurrency)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteDouble(value as Double)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Double, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfDouble)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteInt16(value as Int16)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Int16, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt16)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteInt32(value as Int32)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Int32, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt32)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteInt64(value as Int64)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Int64, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt64)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteInt8(value as Int8)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Int8, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt8)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WritePString(s as String)		  me.WriteUInt8 Min(LenB(s), 255)		  me.Write LeftB(s, 255)		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteSingle(value as Single)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as Single, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfSingle)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteUInt16(value as UInt16)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as UInt16, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt16)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteUInt32(value as UInt32)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as UInt32, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt32)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteUInt64(value as UInt64)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as UInt64, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt64)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		  		End Sub	#tag EndMethod	#tag Method, Flags = &h0		Sub WriteUInt8(value as UInt8)		  soft declare function gzwrite lib zlibPath (file as Ptr, ByRef buf as UInt8, len as UInt32) as Integer		  		  dim bytesWritten as Integer = gzwrite(me.gzFile, value, sizeOfInt8)		  if bytesWritten <= 0 then		    GZipException.RaisegzipError(gzipErrorCode(me.gzFile))		  end if		End Sub	#tag EndMethod	#tag Note, Name = Documentation		zlib		3/22/2007		charles@declareSub.com		http://www.declareSub.com						zlib is a wrapper for the zlib compression library, available on Mac OS X, Linux, and Windows.		It currently consists of a module, zlib, and a class, gzipStream.  Documentation for the zlib module		can be found in the module.						gzipStream is a stream object not unlike BinaryStream that allows to write to and read from files.		Inputs to write methods and outputs from read methods are uncompressed.  Byte size parameters are		for uncompressed data.						Properties				EOF as Boolean (read-only)		  EOF returns true if you are at the end of the file.				IsOpen as Boolean (read-only)		  IsOpen returns true if the file passed in the constructor (see below) was opened for reading or writing. 		  You can use this property to check whether the constructor succeeded.								Position as Integer (read-only)		  Position returns the current position of the stream cursor, in terms of uncompressed bytes.  Currently this property is read-only.		  zlib supports setting the cursor position, but its usage is complicated. I can add it if there is demand.						Shared Methods.				Function Create(f as FolderItem)as GZipStream				If f is nil, expect a NilObjectException.  Creates a GZipStream for writing data to compress at f.  				Function Open(f as FolderItem)as GZipStream				If f is nil, expect a NilObjectException.  If f does not exist, a GZipException should be raised.  Opens a GZipStream for reading compressed data.  It will also		open files not compressed, and read from them.						Methods				Function Read(count as Integer) as String				Read returns an uncompressed string of length at most count bytes from the file.  It may return a shorter string if, for instance, you		hit the end of the file.				There are more convenience functions that read from the file and return data in various datatypes.				Sub Write(text as String)				Write writes the passed string to the file in compressed format.				As with Read, there are several convenience methods to write values of other datatypes to a file.						Using gzipStream				The file is opened using Create or Open, and flushed and closed in the object destructor.  There is no Close method.		So to write data to a new compressed file, you can do the following.				dim b as BinaryStream = BinaryStream.Open(f)		dim gz as GZipStream = GZipStream.Create(f_gz)		gzip.Write b.Read(b.Length)		gzip = nil (or let it go out of scope)						Reading data from a compressed file is more work, because there does not		appear to be a way to retrieve the length of the uncompressed data.  So you should do something 		like this.				dim g as GZipStream = GZipStream.Open(f_gz)		dim b as BinaryStream = BinaryStream.Create(f)		dim uncompressedData() as String		do until gzip.EOF		  b.Write gzip.Read(65536)		loop				You can fiddle with the block size for reads; the number above was chosen for no particular reason.						Decompressing a file into memory:				There are a few ways of decompressing a file into memory.				dim g as GZipStream = GZipStream.Open(f_gz)		dim b as new BinaryStream(new MemoryBlock(0))		do until gzip.EOF		b.Write gzip.Read(65536)		loop				You now have the data in a BinaryStream backed by a MemoryBlock.				dim g as GZipStream = GZipStream.Open(f_gz)		dim buffer() as String		do until gzip.EOF		buffer.Append gzip.Read(65536)		loop		g = nil		dim data as String = Join(buffer, "")				This gives you the uncompressed data in a String.													#tag EndNote	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  //Computed property handlers can be invoked by the debugger.  Thus I check the value of gzFile 			  //even though the constructor is designed to raise an exception if me.gzfile cannot be set to a non-nil value.			  			  soft declare function gzeof lib zlibPath (file as Ptr) as Integer			  			  return (me.gzFile = nil) or (gzeof(me.gzFile) = 1)			End Get		#tag EndGetter		EOF As Boolean	#tag EndComputedProperty	#tag Property, Flags = &h21		Private gzFile As Ptr	#tag EndProperty	#tag ComputedProperty, Flags = &h0		#tag Getter			Get			  if me.gzFile <> nil then			    soft declare function gztell lib zlibPath (file as Ptr) as Integer			    			    return gztell(me.gzFile)			  else			    return 0			  end if			  			  			End Get		#tag EndGetter		Position As Integer	#tag EndComputedProperty	#tag Constant, Name = LibraryPath, Type = String, Dynamic = False, Default = \"", Scope = Private		#Tag Instance, Platform = Linux, Language = Default, Definition  = \"/usr/lib/nptl/libc.so"		#Tag Instance, Platform = Mac OS, Language = Default, Definition  = \"System.framework"	#tag EndConstant	#tag Constant, Name = sizeOfBoolean, Type = Double, Dynamic = False, Default = \"1", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfCurrency, Type = Double, Dynamic = False, Default = \"8", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfDouble, Type = Double, Dynamic = False, Default = \"8", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfInt16, Type = Double, Dynamic = False, Default = \"2", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfInt32, Type = Double, Dynamic = False, Default = \"4", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfInt64, Type = Double, Dynamic = False, Default = \"8", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfInt8, Type = Double, Dynamic = False, Default = \"1", Scope = Private	#tag EndConstant	#tag Constant, Name = sizeOfSingle, Type = Double, Dynamic = False, Default = \"4", Scope = Private	#tag EndConstant	#tag Constant, Name = zlibPath, Type = String, Dynamic = False, Default = \"", Scope = Private		#Tag Instance, Platform = Mac OS, Language = Default, Definition  = \"/usr/lib/libz.dylib"		#Tag Instance, Platform = Windows, Language = Default, Definition  = \"ZLIB1.DLL"		#Tag Instance, Platform = Linux, Language = Default, Definition  = \"/usr/lib/libz.so.1"	#tag EndConstant	#tag ViewBehavior		#tag ViewProperty			Name="EOF"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="Index"			Visible=true			Group="ID"			InitialValue="-2147483648"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="IsOpen"			Group="Behavior"			InitialValue="0"			Type="Boolean"		#tag EndViewProperty		#tag ViewProperty			Name="LastErrorCode"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Left"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Name"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Position"			Group="Behavior"			InitialValue="0"			Type="Integer"		#tag EndViewProperty		#tag ViewProperty			Name="Super"			Visible=true			Group="ID"			InheritedFrom="Object"		#tag EndViewProperty		#tag ViewProperty			Name="Top"			Visible=true			Group="Position"			InitialValue="0"			InheritedFrom="Object"		#tag EndViewProperty	#tag EndViewBehaviorEnd Class#tag EndClass